# convenience methods for processing ast --------------------------------------
#
# TODO: cleanup flow?
# takes an call object, returns an enhanced tree representation (list) with
#   * node id
#   * parent_id
#   * node: call object for node
#   * text: simplified text for nodes that atomic or name types
create_ast_graph <- function(x, acc = NULL, parent_id = 0) {
  if (is.null(acc)) {
    acc <- new.env()
    acc$crnt_n <- 0
    acc$nodes <- list()
  }

  node_id <- acc$crnt_n <- acc$crnt_n + 1
  acc$nodes[[acc$crnt_n]] <- list(
    node = x,
    id = node_id,
    parent = parent_id,
    text = if (is.atomic(x) | is.name(x)) as.character(x) else ""
    )

  if (is.atomic(x) | is.name(x)) {
    NULL
  } else if (is.call(x) | is.expression(x)) {
    for (ii in 1:length(x)) {
      create_ast_graph(x[[ii]], acc, node_id)
    }
  } else {
    stop("unexpected object type in the ast", x)
  }
  return(acc$nodes)
}




# end convenience methods -----

#' Produce an ast or parse graph of an expression
#'
#' @param expr An expression (e.g. created by parse(text = "1 + 1"))
#' @param type Generate a full parse graph or ast
#' @return An igraph graph object
#' @examples
#' create_parse_graph(parse(text = "if (x) 2 else a$b"))
#' create_parse_graph(expression(if (x) 2 else a$b), type = "ast")
#'
#' @importFrom igraph graph.tree vertices edges
#' @export
create_parse_graph <- function(expr, type = c("parse", "ast")[1]) {
  if (type == "parse") {
    y = getParseData(expr)
    # need to add a root node at top of df
    header = y[1,]
    header[1,] = NA
    header[1, 'id'] = 0
    y = rbind(header, y)
  }
  else if (type == "ast") {
    # TODO: replace create_ast_graph w/ something that returns a dataframe
    y = as.data.frame(do.call("rbind", create_ast_graph(expr)))
    y$token = NA
  }
  else {
    stop("type argument should be either 'parse' or 'ast'")
  }

  # find edges
  y$new.id <- seq_along(y$id)
  edge_pairs <- with(y, cbind(new.id[match(parent, id)], new.id))[-1,]

  # create graph
  h <- graph.tree(0) +
    vertices(id = y$new.id, df_id = y$id, token = y$token, label= y$text) +
    edges(c(t(edge_pairs)))
}



#' Produce an ast or parse graph of an expression
#'
#' @param g_parse Parse graph generated by create_parse_graph
#' @param g_ast AST graph generated by create_parse_graph
#' @param parse_node node from g_parse to search from
#' @param ast_node node from g_ast to search from
#' @return A data.frame linking the graphs with columns parse_id, ast_id
#' @examples
#' exp <- parse(text = "if (x) 2 else a$'b'")
#' g <- create_parse_graph(parse(text = "if (x) 2 else a$'b'"))
#' plot(g, layout = layout.reingold.tilford)
#'
#' g_ast <- create_parse_graph(exp, type = "ast")
#' plot(g_ast, layout = layout.reingold.tilford)
#'
#' match_expr(g, g_ast, V(g)[2], V(g_ast)[2])
#'
#' @importFrom igraph V neighbors
#' @export
match_expr <- function(g_parse, g_ast, parse_node, ast_node) {
  parse_children <- V(g_parse)[neighbors(g_parse, parse_node, mode = "out")]
  expr <- parse_children[token == "expr"]

  ast_children <- V(g_ast)[neighbors(g_ast, ast_node)]
  n_ast <- length(ast_children)

  # lispy calls are the same length (e.g. `+`(1,2))
  # but more common use of operators, like 1 + 1, will have 1 less expr
  if (n_ast != length(expr)) {
    op <- parse_children[label == ast_children$label[1]]
    expr <- c(op, expr)

    # check for use of $ operator (e.g. a$'b'),
    # since 'b' is not treated like an expression there
    if (n_ast > length(expr)) {
      quotes <- c('"', "'")
      index_val <- paste0(quotes, ast_children$label[n_ast], quotes)
      indx_op <- parse_children[label %in% index_val]
      stopifnot(length(indx_op) == 1)

      expr <- c(expr, indx_op)
    }

    stopifnot(length(expr) == n_ast)
  }

  data.frame(parse_id = expr$id, ast_id = ast_children$id)
}

#' Produce an ast or parse graph of an expression
#'
#' @param g_parse Parse graph generated by create_parse_graph
#' @param g_ast AST graph generated by create_parse_graph
#' @param id id of ast node to find
#' @return A path of vectors in g_parse leading to corresponding ast node
#' @examples
#' exp <- parse(text = "if (x) 2 else a$'b'")
#' g <- create_parse_graph(parse(text = "if (x) 2 else a$'b'"))
#' plot(g, layout = layout.reingold.tilford)
#'
#' g_ast <- create_parse_graph(exp, type = "ast")
#' plot(g_ast, layout = layout.reingold.tilford)
#'
#' # find code corresponding to `$` call
#' match_path(g, g_ast, V(g_ast)[label == "$"]$id)
#'
#' @importFrom igraph V shortest_paths
#' @export
match_path <- function(g_parse, g_ast, id) {
  V(g_ast)[id]

  nodes <- shortest_paths(g_ast, from = 1, to = id, output = 'vpath', mode = 'out')$vpath[[1]]
  parse_indx <- c(1, rep(NA, length(nodes) - 1))
  v_parse <- V(g_parse)
  for (ii in 2:length(nodes)) {
    crnt_parse_node <- v_parse[parse_indx[ii-1]]
    node <- nodes[ii-1]

    matches <- match_expr(g_parse, g_ast, crnt_parse_node, node)

    # set index for next node
    parse_indx[ii] <- matches$parse_id[matches$ast_id == nodes[ii]$id]
  }

  v_parse[parse_indx]
}

#' Produce an ast or parse graph of an expression
#'
#' @param g_parse Parse graph generated by create_parse_graph
#' @param g_ast AST graph generated by create_parse_graph
#' @param id id of ast node to find
#' @return A path of vectors in g_parse leading to corresponding ast node
#' @examples
#' exp <- parse(text = "if (x) 2 else a$'b'")
#' g <- create_parse_graph(parse(text = "if (x) 2 else a$'b'"))
#' plot(g, layout = layout.reingold.tilford)
#'
#' g_ast <- create_parse_graph(exp, type = "ast")
#' plot(g_ast, layout = layout.reingold.tilford)
#'
#' # find code corresponding to `$` call
#' plot_match(g, g_ast, V(g_ast)[label == "$"]$id)
#'
#' @export
plot_match <- function(g_parse, g_ast, id) {
  parse_path <- match_path(g_parse, g_ast, id)
  igraph::V(g_parse)[parse_path]$color <- 'lightblue'
  plot(g_parse, layout = layout.reingold.tilford)
}
